#!/usr/bin/ruby

require 'chef'
require 'chef/knife'
require 'chef/search/query'
require 'json'
require 'highline'
require 'optparse'

def get_health(node)
  begin
    JSON.parse(`ssh #{node.ec2.public_hostname} curl -s http://localhost:9200/_cluster/health`)
  rescue => e
    STDERR.puts "#{node.name}: error parsing JSON: #{e.message}"
    nil
  end
end

def report_health(clusters, keys)
  clusters.each do |cluster, nodes|
    if es = get_health(nodes[rand(nodes.size)])
      if keys.nil?
        node_count = "#{es['number_of_data_nodes']} + #{es['number_of_nodes'] - es['number_of_data_nodes']}"
        status = HighLine.new.color(es['status'], es['status'].to_sym)
        shard_types = %w{active active_primary relocating initializing unassigned}
        shard_info = shard_types.select {|t| es[t+'_shards'] > 0 }.map {|t| "#{es[t+'_shards']} #{t}" }
        puts "#{cluster} (#{node_count} nodes) is #{status}: #{shard_info.join(', ')}"
      else
        puts keys.map {|k| es[k] }.join(' ')
      end
    end
  end
end

Chef::Knife.new.configure_chef

options = {}
OptionParser.new do |opts|
  opts.on('-w', '--watch SECS', 'repeat every SECS seconds') do |secs|
    options[:watch] = secs.to_i
  end
  opts.on('-r', '--report KEYS', 'print only KEYS (comma-separated)') do |keys|
    options[:report] = keys.split(',')
  end
end.parse!

begin
  rows, start, total = Chef::Search::Query.new.search(:node, "role:elasticsearch_ebs")
  rows.reject! {|node| !ARGV.include? node.elasticsearch.cluster } unless ARGV.empty?
  clusters = rows.group_by {|node| node.elasticsearch.cluster rescue node.app_environment }

  if options[:watch]
    loop do
      report_health(clusters, options[:report])
      STDOUT.flush
      sleep(options[:watch])
    end
  else
    report_health(clusters, options[:report])
  end
rescue Interrupt
end
